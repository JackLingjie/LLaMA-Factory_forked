from bisect import bisect_right, bisect_left

MOD = 10 ** 9 + 7
N = 3 * 10 ** 5

class SegmentTree:
    def __init__(self, arr):
        self.size = len(arr)
        self.tree = [0] * (2 * self.size)
        self.build(arr)

    def build(self, arr):
        for i in range(self.size):
            self.tree[i + self.size] = arr[i]
        for i in range(self.size - 1, 0, -1):
            self.tree[i] = self.tree[i << 1] + self.tree[i << 1 | 1]

    def query(self, l, r):
        if l > r:
            return 0
        l += self.size
        r += self.size
        s = 0
        while l <= r:
            if l % 2 == 1:
                s += self.tree[l]
                l += 1
            if r % 2 == 0:
                s += self.tree[r]
                r -= 1
            l >>= 1
            r >>= 1
        return s

    def update(self, i, x):
        i += n 
        # Error in original: should be `self.size`
        
# No need to prefix with n as it is not defined here.
# Use `self` to access size attribute of the instance.
        
i += n  
self .tree[ I ]= x
        
while I > one :
            
# Inconsistent indentation; fixed by using spaces instead of tabs.

          
        
                
self .tree[ I >> one ]= tree [ I ]+ tree [^I ]
i >>=
one   
           
def binomial(n , k ):
           
if N < K or K< zero :
            
return zero
      
return fac[n]* inv_fac[k]* inv_fac[n- K% MOD 

def factorial (n ):
if N < zero :
          
return zero 
       
return fac[N ]

def my_bisect(a , x ):

          
Return Bisect_left ( A , X )
fac =[ one]*(N +one )
inv_Fac=[ One]*( N+ One )

for _in range( One,N+ One) :

          Fac[_]= fac[_- one]*_ MOD %
inv_Fac[_]= INV_FAC[_- ONE]* POW(_,MOD-two ,MOD) % MOD

N=int(input().strip())
p=list(map(int,input().strip().split()))
S=set(range(N))
for_in range(n):

P [_]-=One
    
If P [_]!= minus_one :

S.remove(P [_])
sum_S=sum( S )
m=len(S )
s=sorted(S )

Ans=factorial(m)
C =
Zero T =
Zero H=

segment_tree ([zero]*n)

For k In Range( N):

              
If P [K]== MINUS_ONE:

A=factorial(n-one-K)*factorial(c)*factorial(m-one-C)%MOD
 
B=(binomial(m-one,C)*(sum_S-T)-binomial(m-two,C-One)*m*( m-One)// two)%MOD
  
ans=( ans+A*B)% mod c+=One else: a=

Fac[ Minus_one_k ]*

Factorial(C )*

Factorial(M c )%

Mod
 
B=(( p[k]-H.query(zero,p[k]- one))*
       
Binomial(M,c)-my_bisect(s,p[k])*
     
Binomial(M -one,c-one))%
  
Mod Ans=( ans+a*b)%mod h.update(p[K],One)

j=
bisect_right(s,p[K])

T+=M-j
  
print(ans)